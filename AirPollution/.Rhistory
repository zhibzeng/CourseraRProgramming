mean(x[i,1:col])
}
print('every col mean:')
for(i in 1:col){
mean(x[1:r,i])
}
}else{
print('Warning: please use dataframe as input !')
}
}
dfmean(x)
dfmean(df)
dfmean <- function(x){
if(is.data.frame(x)){
r <- nrow(x)
col <- ncol(x)
print('every row mean:')
for(i in 1:r){
mean(x[i,1:col])
}
print('every col mean:')
for(i in 1:col){
mean(x[1:r,i])
}
}else{
print('Warning: please use dataframe as input !')
}
}
dfmean(df)
nrow(df)
df[1,1:3]
df[[1,1:3]
]
df[[1,1:3]]
df[[1,]]
df[1,]
df[1,][1:3]
df[[1]]
df[[2]]
df[[3]]
df[[,2]]
df[1,2]
df
df[1,1:3]
df[1,3]
df[1,]
df[1,][1]
df[1,][[1]]
df[1,][[1:3]]
df[1,][[12]]
df[1,1:3]
x <- df[1,1:3]
x
x[1]
x[2]
rm(x)
df[[1]]
df[[,1]]
?data.frame
df[1]
df[[,1]]
df[[1]]
df[[1]][1]
df[[1:3]][1]
df[[1][1]
df$first
df$first
names
names[df]
names(df)
names(df)[1]
names(df)[2]
df$names(df)[2]
name <- df$names(df)[2]
name <- names(df)[2]
df$name
df[names(df)[2]]
df[[names(df)[2]]
]
dfmean <- function(x){
if(is.data.frame(x)){
r <- nrow(x)
col <- ncol(x)
print('every row mean:')
for(i in 1:r){
#mean(x[i,1:col])
}
print('every col mean:')
for(i in 1:col){
mean(df[[names(df)[i]]])
}
}else{
print('Warning: please use dataframe as input !')
}
}
dfmean(df)
dfmean <- function(x){
if(is.data.frame(x)){
r <- nrow(x)
col <- ncol(x)
print('every row mean:')
for(i in 1:r){
#mean(x[i,1:col])
}
print('every col mean:')
for(i in 1:col){
m <- mean(df[[names(df)[i]]])
print(m)
}
}else{
print('Warning: please use dataframe as input !')
}
}
dfmean(df)
df
dfmean <- function(x){
if(is.data.frame(x)){
r <- nrow(x)
col <- ncol(x)
print('every row mean:')
for(i in 1:r){
#mean(x[i,1:col])
}
print('every col mean:')
for(i in 1:col){
m <- mean(df[[names(df)[i]]])
print(mean(df[[names(df)[i]]]))
}
}else{
print('Warning: please use dataframe as input !')
}
}
dfmean(df)
df[1,]
df[1,][]
df[[1,]]
df[1,]
as.vector(df[1,])
df[1,]
df[1,]
sum(df[1,])
mean(df[1,])
dfmean <- function(x){
if(is.data.frame(x)){
r <- nrow(x)
col <- ncol(x)
print('every row mean:')
for(i in 1:r){
print(sum(df[i,])/col)
}
print('every col mean:')
for(i in 1:col){
print(mean(df[[names(df)[i]]]))
}
}else{
print('Warning: please use dataframe as input !')
}
}
dfmean(df)
df
mean(df[,1])
mean(df[1,])
mean(df[,q])
dfmean <- function(x){
if(is.data.frame(x)){
r <- nrow(x)
col <- ncol(x)
colmean <- numeric(col)
rowmean <- numeric(r)
print('every row mean:')
for(i in 1:r){
rowmean[i] <- sum(df[i,])/col
}
rowmean
print('every col mean:')
for(i in 1:col){
colmean[i] <- mean(df[[names(df)[i]]])
}
colmean
}else{
print('Warning: please use dataframe as input !')
}
}
dfmean(df)
dfmean(df)
dfmean <- function(x){
if(is.data.frame(x)){
r <- nrow(x)
col <- ncol(x)
colmean <- numeric(col)
rowmean <- numeric(r)
print('every row mean:')
for(i in 1:r){
rowmean[i] <- (sum(df[i,])/col)
}
rowmean
print('every col mean:')
for(i in 1:col){
colmean[i] <- mean(df[[names(df)[i]]])
}
colmean
}else{
print('Warning: please use dataframe as input !')
}
}
dfmean(df)
dfmean <- function(x){
if(is.data.frame(x)){
r <- nrow(x)
col <- ncol(x)
colmean <- numeric(col)
rowmean <- numeric(r)
print('every row mean:')
for(i in 1:r){
rowmean[i] <- (sum(df[i,])/col)
}
print(rowmean)
print('every col mean:')
for(i in 1:col){
colmean[i] <- mean(df[[names(df)[i]]])
}
colmean
}else{
print('Warning: please use dataframe as input !')
}
}
dfmean(df)
df
inverse
x = as.matrix(1:6,2,3)
x
x = as.matrix(1:6,2,3)
x
dim(x)
x = as.matrix((1:6),2,3)
x
?as.matrix
x = as.matrix((1:6),nrow = 2,ncol = 3)
x
as.matrix(1:10)
x = as.matrix(c(1,2,3,4,5,6),nrow = 2,ncol = 3)
x
x = matrix(c(1,2,3,4,5,6),nrow = 2,ncol = 3)
x
invisible(x)
x = as.matrix(c(1,2,3,4,5,6,7,8,9),nrow = 3,ncol = 3)
invisible(x)
x
x = matrix(c(1,2,3,4,5,6,7,8,9),nrow = 3,ncol = 3)
invisible(x)
c
x
makeCacheMatrix <- function(x = matrix()) {
inverseM <- NULL
set <- function(y){
x <<- y
inverseM <<- NULL
}
get <- function() x
setInverseM <- function(im) inverseM <<- im
getInverseM <- function() inverseM
list(set = set, get = get,
setInverseM = setInverseM,
getInverseM = getInverseM
)
}
x''
x'
}
d
''
ls
x
x+1
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
# judge x weather x is a square matrix, if not return error message
inverseM <- x$getInverseM()
if(!is.null(inverseM)){
message("getting cached data")
return(inverseM)
}
data <- x$get()
inverseM <- sapply(x,function(y){y+1}) # inverse the matrix
x$setInverseM(inverseM)
return(inverseM)
}
superM <- makeCacheMatrix(x)
superM$setInverseM
superM$setInverseM()
superM$getInverseM()
cacheSolve(superM)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
# judge x weather x is a square matrix, if not return error message
inverseM <- x$getInverseM()
if(!is.null(inverseM)){
message("getting cached data")
return(inverseM)
}
data <- x$get()
inverseM <- sapply(data,function(y){y+1}) # inverse the matrix
x$setInverseM(inverseM)
return(inverseM)
}
cacheSolve(superM)
x
cacheSolve(superM)
cacheSolve(superM)
as.matrix( cacheSolve(superM))
as.matrix(cacheSolve(superM),nrow=3,ncol=3)
matrix(cacheSolve(superM),nrow=3,ncol=3)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
# judge x weather x is a square matrix, if not return error message
inverseM <- x$getInverseM()
if(!is.null(inverseM)){
message("getting cached data")
return(inverseM)
}
data <- x$get()
inverseM <- apply(data,function(y){y+1}) # inverse the matrix
x$setInverseM(inverseM)
return(inverseM)
}
cacheSolve(superM)
superM$set(NULL)
cacheSolve(superM)
superM$set(null)
superM$getInverseM()
cacheSolve(superM)
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
# judge x weather x is a square matrix, if not return error message
inverseM <- x$getInverseM()
if(!is.null(inverseM)){
message("getting cached data")
return(inverseM)
}
data <- x$get()
inverseM <- apply(data,FUN=function(y){y+1}) # inverse the matrix
x$setInverseM(inverseM)
return(inverseM)
}
cacheSolve(superM)
x
?apply
?mapply
mapply(rep, times = 1:4, MoreArgs = list(x = 42))
?apply
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
# judge x weather x is a square matrix, if not return error message
inverseM <- x$getInverseM()
if(!is.null(inverseM)){
message("getting cached data")
return(inverseM)
}
data <- x$get()
inverseM <- apply(data,1:2,function(y){y+1}) # inverse the matrix
x$setInverseM(inverseM)
return(inverseM)
}
cacheSolve(superM)
superM
superM$get()
superM$set(x)
ls
cacheSolve(superM)
cacheSolve(superM)
cacheSolve(superM)
cacheSolve(superM)
cacheSolve(superM)
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
# judge x weather x is a square matrix, if not return error message
inverseM <- x$getInverseM()
if(!is.null(inverseM)){
message("getting cached data")
return(inverseM)
}
data <- x$get()
inverseM <- apply(data,function(y){y+1}) # inverse the matrix
x$setInverseM(inverseM)
return(inverseM)
}
superM$set(x)
superM$getInverseM()
cacheSolve(superM)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
# judge x weather x is a square matrix, if not return error message
inverseM <- x$getInverseM()
if(!is.null(inverseM)){
message("getting cached data")
return(inverseM)
}
data <- x$get()
inverseM <- apply(data,1:2,function(y){y+1}) # inverse the matrix
x$setInverseM(inverseM)
return(inverseM)
}
superM$set(x)
cacheSolve(superM)
cacheSolve(superM)
cacheSolve(superM)
cacheSolve(superM)
cacheSolve(superM)
cacheSolve(superM)
load("~/R/RCode/Coursera/coursera.RData")
x
solve(x)
x
tau <- c(0, 0, 0, 0, 1,
1, 0, 0, 0, 0,
0, 1, 0, 0, 0,
0, 0, 1, 0, 0,
0, 0, 0, 1, 0)
tau <- matrix(tau, ncol=5, byrow=TRUE)
tau
solve(tau)
sub.tau <- subset(tau[1:4,1:5])
sub.tau
solve(sub.tau)
makeCacheMatrix <- function(x = matrix()) {
inverseM <- NULL
set <- function(y){
x <<- y
inverseM <<- NULL
}
get <- function() x
setInverseM <- function(im) inverseM <<- im
getInverseM <- function() inverseM
list(set = set, get = get,
setInverseM = setInverseM,
getInverseM = getInverseM
)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x$getInverseM()
if(!is.null(inverseM)){
message("getting cached data")
return(inverseM)
}
data <- x$get()
inverseM <- solve(data) # inverse the matrix
x$setInverseM(inverseM)
return(inverseM)
}
x
x
x
tau
superM <- makeCacheMatrix(tau)
superM$get()
superM$getInverseM()
cacheSolve(superM)
cacheSolve(superM)
cacheSolve(superM)
cacheSolve(superM)
cacheSolve(superM)
cacheSolve(superM)
cacheSolve(superM)
log(-1)
invisible(x)
x
lm(y~x)
traceback()
debug(lm(y~x))
debug()
debug(lm(y~x))
debug(lm(y~x))
debug(lm)
lm(y~x)
library(datasets)
data(iris)
?data
data()
?iris
iris
head(iris)
vir.iris <- subset(iris,iris$Species=='virginica')
vir.iris
mean(vir.iris$Sepal.Length)
colMeans(iris)
apply(iris[, 1:4], 2, mean)
library(datasets)
data(mtcars)
?mtcars
head(mtcars)
tapply(mtcars$mpg, mtcars$cyl, mean)
?tapply
tapply(mtcars$mpg,mtcars$cyl,mean)
sapll
tapply(mtcars$hp,mtcars$cyl)
tapply(mtcars$hp,mtcars$cyl,mean)
tapply(mtcars$hp,mtcars$cyl,mean)[1]
tapply(mtcars$hp,mtcars$cyl,mean)[[1]]
tapply(mtcars$hp,mtcars$cyl,mean)[[1]]-tapply(mtcars$hp,mtcars$cyl,mean)[[3]]
debug(ls)
ls
ls()
nn
nn
nn
setwd("~/R/RCode/Coursera/AirPollution")
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript1.R")
submit()
